<template>
  <div class="vdatetime-popup">
    <div class="vdatetime-popup__header">
      <div v-if="title" class="vdatetime-popup__title">{{ title }}</div>
      <div v-if="type !== 'time'" class="vdatetime-popup__year" @click="showYear">{{ year }}</div>
      <div v-if="type !== 'time'" class="vdatetime-popup__date" @click="showMonth">{{ dateFormatted }}</div>
    </div>
    <div class="vdatetime-popup__body">
      <datetime-year-picker
        v-if="step === 'year'"
        :min-date="minDatetime"
        :max-date="maxDatetime"
        :year="year"
        @change="onChangeYear"
      />
      <datetime-month-picker
        v-if="step === 'month'"
        :min-date="minDatetime"
        :max-date="maxDatetime"
        :year="year"
        :month="month"
        @change="onChangeMonth"
      />
      <datetime-calendar
        v-if="step === 'date'"
        :year="year"
        :month="month"
        :day="day"
        :min-date="minDatetime"
        :max-date="maxDatetime"
        :week-start="weekStart"
        @change="onChangeDate"
      />
      <datetime-time-picker
        v-if="step === 'time'"
        :hour="hour"
        :minute="minute"
        :use12-hour="use12Hour"
        :hour-step="hourStep"
        :minute-step="minuteStep"
        :min-time="minTime"
        :max-time="maxTime"
        @change="onChangeTime"
      />
    </div>
    <div class="vdatetime-popup__actions">
      <div class="vdatetime-popup__actions__button vdatetime-popup__actions__button--cancel" @click="cancel">
        <slot name="button-cancel__internal" :step="step">{{ phrases.cancel }}</slot>
      </div>
      <div class="vdatetime-popup__actions__button vdatetime-popup__actions__button--confirm" @click="confirm">
        <slot name="button-confirm__internal" :step="step">{{ phrases.ok }}</slot>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { DateTime } from 'luxon';
import { computed, PropType, ref } from 'vue';

import useKeyPressListener from './composables/KeyPress';
import DatetimeCalendar from './DatetimeCalendar.vue';
import DatetimeMonthPicker from './DatetimeMonthPicker.vue';
import DatetimeTimePicker from './DatetimeTimePicker.vue';
import DatetimeYearPicker from './DatetimeYearPicker.vue';
import { createFlowManager, createFlowManagerFromType } from './util';

const props = defineProps({
  datetime: {
    type: Object as PropType<DateTime>,
    required: true,
  },
  phrases: {
    type: Object as PropType<PopupActions>,
    default() {
      return {
        cancel: 'Cancel',
        ok: 'Ok',
      };
    },
  },
  type: {
    type: String,
    default: 'date',
  },
  use12Hour: {
    type: Boolean,
    default: false,
  },
  hourStep: {
    type: Number,
    default: 1,
  },
  minuteStep: {
    type: Number,
    default: 1,
  },
  minDatetime: {
    type: Object as PropType<DateTime>,
    default: null,
  },
  maxDatetime: {
    type: Object as PropType<DateTime>,
    default: null,
  },
  auto: {
    type: Boolean,
    default: false,
  },
  weekStart: {
    type: Number,
    default: 1,
  },
  flow: { type: Array, default: null },
  title: { type: String, default: '' },
});

const emits = defineEmits(['cancel', 'confirm']);

interface TimeParts {
  year?: boolean,
  month?: boolean,
  day?: boolean,
  hour?: boolean,
  minutes?: boolean,
  suffix?: boolean,
}

interface PopupActions {
  cancel?: string,
  ok?: string,
}

const flowManager = props.flow ? createFlowManager(props.flow) : createFlowManagerFromType(props.type.valueOf());
const newDateTime = ref<DateTime>(props.datetime ?? DateTime.now());
const step = ref<string>(flowManager.first());
let timePartsTouched = {} as TimeParts;

const nextStep = () => {
  step.value = flowManager.next(step.value);
  timePartsTouched = {};

  if (step.value === 'end') {
    emits('confirm', newDateTime.value);
  }
};

const confirm = () => {
  nextStep();
};

const cancel = () => {
  emits('cancel');
};

useKeyPressListener((event: KeyboardEvent) => {
  switch (event.key) {
  case 'Escape':
  case 'Tab':
    cancel();
    break;

  case 'Enter':
    nextStep();
    break;
  default:
    break;
  }
});

const year = computed<number>(() => newDateTime.value.year);
const month = computed<number>(() => newDateTime.value.month);
const day = computed<number>(() => newDateTime.value.day);
const hour = computed<number>(() => newDateTime.value.hour);
const minute = computed<number>(() => newDateTime.value.minute);
const dateFormatted = computed<string>(() => newDateTime.value.toLocaleString({
  month: 'long',
  day: 'numeric',
}));

const minTime = computed<string | undefined>(() => ((
  props.minDatetime &&
  props.minDatetime.year === year.value &&
  props.minDatetime.month === month.value &&
  props.minDatetime.day === day.value
) ? props.minDatetime.toFormat('HH:mm') : undefined));

const maxTime = computed<string | undefined>(() => ((
  props.maxDatetime &&
  props.maxDatetime.year === year.value &&
  props.maxDatetime.month === month.value &&
  props.maxDatetime.day === day.value
) ? props.maxDatetime.toFormat('HH:mm') : undefined));

const showYear = () => {
  step.value = 'year';
  flowManager.diversion('date');
};

const showMonth = () => {
  step.value = 'month';
  flowManager.diversion('date');
};

const onChangeYear = (year: number) => {
  newDateTime.value = newDateTime.value.set({ year });

  if (props.auto.valueOf()) {
    nextStep();
  }
};

const onChangeMonth = (newValue: number) => {
  newDateTime.value = newDateTime.value.set({ month: newValue });

  if (props.auto) {
    nextStep();
  }
};

const onChangeDate = (year: number, month: number, day: number) => {
  newDateTime.value = newDateTime.value.set({ year, month, day });

  if (props.auto.valueOf()) {
    nextStep();
  }
};

const onChangeTime = ({ hour, minute, suffixTouched }: { hour: number, minute: number, suffixTouched: boolean }) => {
  if (suffixTouched) {
    timePartsTouched.suffix = true;
  }

  if (Number.isInteger(hour)) {
    newDateTime.value = newDateTime.value.set({ hour });
    timePartsTouched.hour = true;
  }

  if (Number.isInteger(minute)) {
    newDateTime.value = newDateTime.value.set({ minute });
    timePartsTouched.minutes = true;
  }
};

</script>

<style>
.vdatetime-popup {
  box-sizing: border-box;
  z-index: 1000;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 340px;
  max-width: calc(100% - 30px);
  box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.3);
  color: #444;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
  line-height: 1.18;
  background: #fff;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
}

.vdatetime-popup * {
  box-sizing: border-box;
}

.vdatetime-popup__header {
  padding: 18px 30px;
  background: #3f51b5;
  color: #fff;
  font-size: 32px;
}

.vdatetime-popup__title {
  margin-bottom: 8px;
  font-size: 21px;
  font-weight: 300;
}

.vdatetime-popup__year {
  font-weight: 300;
  font-size: 14px;
  opacity: 0.7;
  cursor: pointer;
  transition: opacity .3s;
}

.vdatetime-popup__year:hover {
  opacity: 1;
}

.vdatetime-popup__date {
  line-height: 1;
  cursor: pointer;
}

.vdatetime-popup__actions {
  padding: 0 20px 10px 30px;
  text-align: right;
}

.vdatetime-popup__actions__button {
  display: inline-block;
  border: none;
  padding: 10px 20px;
  background: transparent;
  font-size: 16px;
  color: #3f51b5;
  cursor: pointer;
  transition: color .3s;
}

.vdatetime-popup__actions__button:hover {
  color: #444;
}
</style>
